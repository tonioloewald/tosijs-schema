var D=(x)=>({schema:x,_type:null,get optional(){return D({...x,type:Array.isArray(x.type)?[...x.type,"null"]:[x.type,"null"]})},min:(j)=>{let C=x.type==="string"?"minLength":x.type==="array"?"minItems":"minimum";return D({...x,[C]:j})},max:(j)=>{let C=x.type==="string"?"maxLength":x.type==="array"?"maxItems":"maximum";return D({...x,[C]:j})},pattern:(j)=>D({...x,pattern:typeof j==="string"?j:j.source}),get email(){return D({...x,format:"email"})},get uuid(){return D({...x,format:"uuid"})},get ipv4(){return D({...x,format:"ipv4"})},get url(){return D({...x,format:"uri"})},get datetime(){return D({...x,format:"date-time"})},get emoji(){return D({...x,pattern:"^\\p{Extended_Pictographic}+$",format:"emoji"})},get int(){return D({...x,type:"integer"})},step:(j)=>D({...x,multipleOf:j})}),Q={union:(x)=>D({anyOf:x.map((j)=>j.schema)}),enum:(x)=>D({type:typeof x[0],enum:x}),array:(x)=>D({type:"array",items:x.schema}),tuple:(x)=>D({type:"array",items:x.map((j)=>j.schema),minItems:x.length,maxItems:x.length}),object:(x)=>{let j={},C=[];for(let z in x)j[z]=x[z].schema,C.push(z);return D({type:"object",properties:j,required:C,additionalProperties:!1})}},R=new Proxy(Q,{get(x,j){if(j in x)return x[j];if(j==="string"||j==="number"||j==="boolean"){let C=D({type:j});return x[j]=C,C}return}});var P={email:(x)=>/^\S+@\S+\.\S+$/.test(x),uuid:(x)=>/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(x),uri:(x)=>{try{return new URL(x),!0}catch{return!1}},ipv4:(x)=>/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(x),"date-time":(x)=>!isNaN(Date.parse(x)),emoji:(x)=>new RegExp("\\p{Extended_Pictographic}","u").test(x)};function I(x,j){if(j.anyOf){for(let z of j.anyOf)if(I(x,z))return!0;return!1}if(x===null||x===void 0)return Array.isArray(j.type)&&j.type.includes("null");let C=Array.isArray(j.type)?j.type[0]:j.type;if(j.enum&&!j.enum.includes(x))return!1;if(C==="integer"){if(typeof x!=="number"||!Number.isInteger(x))return!1}else if(C==="array"){if(!Array.isArray(x))return!1}else if(C==="object"){if(typeof x!=="object"||Array.isArray(x))return!1}else if(C&&typeof x!==C)return!1;if(typeof x==="number"){if(j.minimum!==void 0&&x<j.minimum)return!1;if(j.maximum!==void 0&&x>j.maximum)return!1;if(j.multipleOf!==void 0&&x%j.multipleOf!==0)return!1}if(typeof x==="string"){if(j.minLength!==void 0&&x.length<j.minLength)return!1;if(j.maxLength!==void 0&&x.length>j.maxLength)return!1;if(j.pattern&&!new RegExp(j.pattern,j.format==="emoji"?"u":"").test(x))return!1;if(j.format&&P[j.format]&&!P[j.format](x))return!1}if(C==="object"&&j.properties){if(j.required){for(let z of j.required)if(!(z in x))return!1}for(let z in j.properties)if(z in x&&!I(x[z],j.properties[z]))return!1}if(C==="array"&&j.items){let z=x.length;if(j.minItems!==void 0&&z<j.minItems)return!1;if(j.maxItems!==void 0&&z>j.maxItems)return!1;if(Array.isArray(j.items)){for(let w=0;w<j.items.length;w++)if(!I(x[w],j.items[w]))return!1;return!0}if(z>0){let w=z<=97?1:Math.floor(z/97);for(let G=0;G<z-1;G+=w)if(!I(x[G],j.items))return!1;if(!I(x[z-1],j.items))return!1}}return!0}function J(x,j){if(JSON.stringify(x)===JSON.stringify(j))return null;if(x.anyOf||j.anyOf){if(JSON.stringify(x.anyOf)!==JSON.stringify(j.anyOf))return{error:"Union mismatch",from:x.anyOf,to:j.anyOf};return null}if(x.type!==j.type)return{error:`Type mismatch: ${x.type} vs ${j.type}`};if(x.type==="object"){let w={},G=new Set([...Object.keys(x.properties||{}),...Object.keys(j.properties||{})]),E=!1;return G.forEach((H)=>{let K=x.properties?.[H],N=j.properties?.[H];if(!K)w[H]={error:"Added in B"},E=!0;else if(!N)w[H]={error:"Removed in B"},E=!0;else{let O=J(K,N);if(O)w[H]=O,E=!0}}),E?w:null}if(x.type==="array"){if(Array.isArray(x.items)&&Array.isArray(j.items)){if(x.items.length!==j.items.length)return{error:"Tuple length mismatch"};let w={},G=!1;for(let E=0;E<x.items.length;E++){let H=J(x.items[E],j.items[E]);if(H)w[E]=H,G=!0}return G?{items:w}:null}if(!Array.isArray(x.items)&&!Array.isArray(j.items)){let w=J(x.items,j.items);return w?{items:w}:null}return{error:"Array type mismatch (Tuple vs List)"}}let C={},z=!1;return["minimum","maximum","minLength","pattern","format","enum"].forEach((w)=>{if(JSON.stringify(x[w])!==JSON.stringify(j[w]))C[w]={from:x[w],to:j[w]},z=!0}),z?C:null}export{I as validate,R as s,J as diff};
